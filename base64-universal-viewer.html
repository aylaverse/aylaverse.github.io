<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Aylaverse ‚Äî Base64 Universal Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="favicon.svg"/>

  <link rel="stylesheet" href="shared-header.css">
  <style>
    * { box-sizing: border-box; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; }

    body {
      margin: 0;
      padding: 20px;
      background: radial-gradient(circle at 0% 0%, #dbeafe 0, #e5e7eb 45%, #eef2ff 100%);
      color: #0f172a;
      overflow-x: hidden;
    }
    
    body.dark {
      background: radial-gradient(circle at 10% 10%, #07101a 0, #0b1320 40%, #08111a 100%);
      color: #e6eef8;
    }

    /* header/logo moved to shared-header.css */

    /* Buttons: match XML editor look */
    button {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(135deg,#6366f1,#22d3ee);
      color: white;
      box-shadow: 0 8px 22px rgba(56,189,248,0.18);
      transition: transform .08s ease, box-shadow .12s ease;
    }

    button.secondary { background: transparent; color: #0f172a; box-shadow: none; border: 1px solid rgba(99,102,241,0.12); }
    button.secondary:hover { background: #eef2ff; }
    button:active { transform: translateY(0); box-shadow: 0 4px 10px rgba(15,23,42,0.12); }

    /* Dark mode tweaks */
    body.dark button {
      background: linear-gradient(135deg,#2b2350,#3b2a60);
      color: #f3f0ff;
    }

    body.dark a.download-link {
      background: linear-gradient(135deg,#2b2350,#3b2a60);
      color: #fff;
      box-shadow: 0 8px 20px rgba(0,0,0,0.4);
    }

    /* SVG icons inside buttons/links */
    button svg, a.download-link svg { width:16px; height:16px; display:inline-block; vertical-align:middle; fill:currentColor; }

    h2 { margin: 6px 0 4px; }

    textarea {
      width: 100%;
      height: 180px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.6);
      background: #ffffff;
      color: #0f172a;
      padding: 10px;
      font-family: monospace;
      resize: vertical;
    }
    
      body.dark textarea {
        background: #0f1724;
        color: #dbeafe;
        border-color: rgba(255,255,255,0.06);
      }

    #msg { margin-top: 8px; font-size: 13px; }
    #msg.error { color: #ef4444; font-weight:600; }
    #msg.ok { color: #16a34a; font-weight:500; }

    /* Viewer layout with sidebar-like file list card */
    #viewerWrapper { margin-top: 12px; display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap; }

    #fileList {
      flex: 0 0 240px;
      min-width: 180px;
      max-height: 600px;
      overflow:auto;
      border-radius: 14px;
      padding: 10px;
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(148,163,184,0.6);
      box-shadow: 0 10px 28px rgba(15,23,42,0.08);
      font-size: 13px;
      display: none; /* kept hidden by JS unless ZIP */
    }
    
      body.dark #fileList {
        background: rgba(10,14,18,0.7);
        border-color: rgba(255,255,255,0.04);
        box-shadow: 0 10px 28px rgba(0,0,0,0.6);
      }

    #fileList h4 { margin: 0 0 8px; }

    .file-item { padding:6px 8px; border-radius:8px; margin-bottom:6px; cursor:pointer; background: #fff; border:1px solid #eef2ff; }
    .file-item:hover { background: linear-gradient(135deg,#eef2ff,#f8fbff); }
    .file-item.folder { font-weight:600; }
    .file-item small { display:block; font-size:11px; color:#64748b; }

    #viewer { flex:1 1 460px; min-height:300px; }

    object, iframe, pre { width:100%; border-radius:14px; border:1px solid rgba(148,163,184,0.6); background: #ffffff; color: #0f172a; }
    object, iframe { height:600px; }
    pre { padding:12px; max-height:600px; overflow:auto; font-size:13px; }
    
      body.dark object, body.dark iframe, body.dark pre {
        background: #0b1116;
        color: #e6eef8;
        border-color: rgba(255,255,255,0.04);
      }

    img.viewer-image { max-width:100%; height:auto; display:block; border-radius:12px; border:1px solid rgba(148,163,184,0.6); }

    a.download-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 13px;
      color: #ffffff;
      text-decoration: none;
      background: linear-gradient(135deg, #6366f1, #22d3ee);
      box-shadow: 0 8px 20px rgba(99,102,241,0.12);
      transition: transform .08s ease, box-shadow .12s ease, opacity .12s ease;
    }

    a.download-link:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 28px rgba(99,102,241,0.18);
      opacity: 0.98;
    }

    a.download-link:active {
      transform: translateY(0);
      box-shadow: 0 6px 16px rgba(15,23,42,0.12);
    }
    .note { margin-top:8px; font-size:12px; color:#475569; }

    footer { margin-top:40px; padding:20px 0; text-align:center; font-size:13px; color:#64748b; }

    @media (max-width:900px) {
      #viewerWrapper { flex-direction:column; }
      #fileList { width:100%; }
    }
  </style>
</head>

<body>

<header>
  <a href="index.html" class="logo logo-link" aria-label="Back to Aylaverse Home">
    <div class="logo-icon">A</div>
    <div>
      <div class="logo-text-main">Aylaverse Tools</div>
      <div class="logo-text-sub">Browser micro‚Äëapps & utilities</div>
    </div>
  </a>

  <div style="display:flex; gap:8px; align-items:center;">
    <button type="button" class="secondary" onclick="window.location.href='index.html'">‚Üê Back to tools</button>
    <button id="themeToggle">üåô Dark Mode</button>
  </div>
</header>

<h2>Base64 Universal Viewer</h2>
<p style="font-size:13px;color:var(--subtle);">
  Paste any <b>Base64</b> data here (raw Base64 or <code>data:...;base64,</code> format).<br>
  You can also paste <b>raw HTML</b> (not Base64-encoded) and it will be displayed safely (scripts disabled).
</p>

<textarea id="b64" placeholder="Paste Base64 or raw HTML here..."></textarea><br>
<button id="btnShow"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8S1 12 1 12z"/></svg> Decode &amp; Display</button>
<button id="btnClear" class="secondary"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg> Clear</button>
<button id="downloadTop" style="display:none;" title="No file ready to download"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 3v12M7 8l5 5 5-5M5 21h14" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg> Download File</button>
<div id="msg"></div>

<div id="viewerWrapper">
  <div id="fileList" style="display:none;"></div>
  <div id="viewer"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
  /* ========== THEME / DARK MODE ========== */
  const themeBtn = document.getElementById("themeToggle");

  function applyTheme(mode){
    if(mode === "dark") {
      document.body.classList.add("dark");
      themeBtn.textContent = "‚òÄÔ∏è Light Mode";
    } else {
      document.body.classList.remove("dark");
      themeBtn.textContent = "üåô Dark Mode";
    }
    localStorage.setItem("aylaverse-theme", mode);
  }

  themeBtn.addEventListener("click", () => {
    const dark = document.body.classList.contains("dark");
    applyTheme(dark ? "light" : "dark");
  });

  // initial theme
  applyTheme(localStorage.getItem("aylaverse-theme") || "light");


  /* ========== VIEWER LOGIC ========== */

  const ta     = document.getElementById('b64');
  const btn    = document.getElementById('btnShow');
  const btnCl  = document.getElementById('btnClear');
  const msg    = document.getElementById('msg');
  const viewer = document.getElementById('viewer');
  const fileList = document.getElementById('fileList');
  const downloadTop = document.getElementById('downloadTop');

  // Track latest downloadable URL + filename so the top button can reuse it
  let currentDownloadUrl = null;
  let currentDownloadName = null;

  function setCurrentDownload(url, name) {
    // revoke previous object URL if it's a blob URL (not a data: URL)
    if (currentDownloadUrl && currentDownloadUrl.startsWith('blob:') && currentDownloadUrl !== url) {
      try { URL.revokeObjectURL(currentDownloadUrl); } catch (e) {}
    }
    currentDownloadUrl = url || null;
    currentDownloadName = name || null;
    if (downloadTop) {
      if (currentDownloadUrl) {
        downloadTop.style.display = 'inline-flex';
        downloadTop.classList.remove('secondary');
        downloadTop.title = 'Download: ' + (currentDownloadName || 'file');
      } else {
        downloadTop.style.display = 'none';
        downloadTop.classList.add('secondary');
        downloadTop.title = 'No file ready to download';
      }
    }
  }

  // top-download button behavior
  if (downloadTop) {
    downloadTop.addEventListener('click', (e) => {
      if (!currentDownloadUrl) return;
      const a = document.createElement('a');
      a.href = currentDownloadUrl;
      if (currentDownloadName) a.download = currentDownloadName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      // do not revoke here because the URL may be reused until a new file replaces it
    });
  }

  // small inline SVG used in generated download anchors
  const _svgDownload = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" style="width:16px;height:16px;flex-shrink:0;display:inline-block;vertical-align:middle;fill:currentColor"><path d="M12 3v12M7 8l5 5 5-5M5 21h14" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>';

  function makeDownloadAnchor(href, filename, label){
    const a = document.createElement('a');
    a.href = href;
    if (filename) a.download = filename;
    a.className = 'download-link';
    a.innerHTML = _svgDownload + ' ' + (label || (filename || 'Download'));
    return a;
  }

  btn.addEventListener('click', handleShow);
  btnCl.addEventListener('click', () => {
    ta.value = '';
    msg.textContent = '';
    msg.className = '';
    viewer.innerHTML = '';
    fileList.style.display = 'none';
    fileList.innerHTML = '';
    setCurrentDownload(null);
  });

  function setMessage(text, type){
    msg.textContent = text;
    msg.className = type || '';
  }

  function stripDataUrlPrefix(s){
    const m = s.match(/^data:([^;]+);base64,(.*)$/is);
    if (m) return { mime: m[1], data: m[2] };
    return { mime: null, data: s };
  }

  function cleanBase64(b64){
    return (b64 || '').replace(/[^A-Za-z0-9+/=]/g, '');
  }

  function isLikelyPdf(cleaned){
    return cleaned.startsWith('JVBERi'); // %PDF
  }

  function isLikelyZip(cleaned){
    return cleaned.startsWith('UEsDB') || cleaned.startsWith('UEsH');
  }

  function b64ToUint8Array(b64){
    if (b64.length % 4 !== 0){
      b64 += '='.repeat(4 - (b64.length % 4));
    }
    const binary = atob(b64);
    const len = binary.length;
    const bytes = new Uint8Array(len);
    for (let i=0;i<len;i++) bytes[i] = binary.charCodeAt(i);
    return bytes;
  }

  function utf8Decode(bytes){
    if (window.TextDecoder){
      try {
        return new TextDecoder('utf-8').decode(bytes);
      } catch(e){}
    }
    let binary = '';
    for (let i=0;i<bytes.length;i++){
      binary += String.fromCharCode(bytes[i]);
    }
    try {
      return decodeURIComponent(escape(binary));
    } catch(e){
      return binary;
    }
  }

  function detectMagic(bytes){
    const s = n => String.fromCharCode.apply(null, Array.from(bytes.slice(0,n)));
    if (bytes.length >= 4 && s(4).startsWith('%PDF')) return 'application/pdf';
    if (bytes.length >= 4 && bytes[0]==0x50 && bytes[1]==0x4b && bytes[2]==0x03 && bytes[3]==0x04) return 'application/zip';
    if (bytes.length >= 4 && bytes[0]==0x89 && bytes[1]==0x50 && bytes[2]==0x4e && bytes[3]==0x47) return 'image/png';
    if (bytes.length >= 2 && bytes[0]==0xff && bytes[1]==0xd8) return 'image/jpeg';
    const start = s(64).trimStart().toLowerCase();
    if (start.startsWith('<!doctype html') || start.startsWith('<html') || start.startsWith('<head') || start.startsWith('<body')) return 'text/html';
    if (start.startsWith('<') || start.startsWith('<?xml')) return 'text/xml';
    return null;
  }

  function showPdfFromBase64(cleaned){
    viewer.innerHTML = '';
    fileList.style.display = 'none';
    fileList.innerHTML = '';

    const url = 'data:application/pdf;base64,' + cleaned;
    const obj = document.createElement('object');
    obj.type = 'application/pdf';
    obj.data = url;
    viewer.appendChild(obj);

    setCurrentDownload(url, 'document.pdf');

    setMessage('PDF loaded successfully.', 'ok');
  }

  function showHtmlString(html, name, downloadUrl){
    viewer.innerHTML = '';
    const iframe = document.createElement('iframe');
    iframe.setAttribute('sandbox', '');
    iframe.style.width = '100%';
    iframe.style.height = '600px';
    iframe.style.border = '1px solid var(--border)';
    iframe.style.borderRadius = '8px';
    iframe.srcdoc = html;
    viewer.appendChild(iframe);

    const note = document.createElement('div');
    note.className = 'note';
    note.textContent = 'Displaying HTML' + (name ? ': ' + name : '') + ' (scripts disabled).';
    viewer.appendChild(note);

    if (downloadUrl){
      setCurrentDownload(downloadUrl, name || 'file.html');
    } else {
      setCurrentDownload(null);
    }
  }

  async function showZipFromBase64(cleaned){
    viewer.innerHTML = '';
    fileList.innerHTML = '<h4>ZIP Content</h4>';
    fileList.style.display = 'block';

    let bytes;
    try {
      bytes = b64ToUint8Array(cleaned);
    } catch (e) {
      setMessage('ZIP Base64 decode error: ' + e.message, 'error');
      return;
    }

    try {
      const zip = await JSZip.loadAsync(bytes);
      const names = Object.keys(zip.files).sort();

      if (!names.length){
        fileList.innerHTML += '<div class="file-item">ZIP appears to be empty.</div>';
        setMessage('ZIP file is empty.', 'error');
        return;
      }

      names.forEach(name => {
        const zf = zip.files[name];
        const div = document.createElement('div');
        div.className = 'file-item' + (zf.dir ? ' folder' : '');
        div.textContent = name + (zf.dir ? ' /' : '');
        if (!zf.dir){
          div.addEventListener('click', async () => {
            await displayZipFile(zf, name);
          });
        }
        fileList.appendChild(div);
      });

      setMessage('ZIP extracted. Click a file to preview it.', 'ok');
    } catch (e){
      setMessage('Error opening ZIP: ' + e.message, 'error');
    }
  }

  async function displayZipFile(file, name){
    viewer.innerHTML = '';
    setMessage('Loading selected file: ' + name, '');

    const lower = name.toLowerCase();
    let expectedType = '';
    if (lower.endsWith('.pdf')) expectedType = 'application/pdf';
    else if (lower.endsWith('.png')) expectedType = 'image/png';
    else if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) expectedType = 'image/jpeg';
    else if (lower.endsWith('.gif')) expectedType = 'image/gif';
    else if (lower.endsWith('.xml')) expectedType = 'text/xml';
    else if (lower.endsWith('.html') || lower.endsWith('.htm')) expectedType = 'text/html';
    else if (lower.endsWith('.txt')) expectedType = 'text/plain';

    try {
      const uint8 = await file.async('uint8array');
      const magicType = detectMagic(uint8);
      const finalType = expectedType || magicType || 'application/octet-stream';

      if (finalType.includes('html')) {
        const html = utf8Decode(uint8);
        const blob = new Blob([html], {type:'text/html'});
        const url = URL.createObjectURL(blob);
        showHtmlString(html, name, url);
      } else if (finalType.startsWith('text') || finalType.includes('xml')) {
        const text = utf8Decode(uint8);
        const pre = document.createElement('pre');
        pre.textContent = text;
        viewer.appendChild(pre);

        const blob = new Blob([text], {type: finalType || 'text/plain'});
        const url = URL.createObjectURL(blob);
        setCurrentDownload(url, name || 'file.txt');
      } else {
        const blob = new Blob([uint8], {type: finalType});
        displayBlob(blob, name, finalType);
      }

      setMessage('Displaying file: ' + name, 'ok');
    } catch(e){
      setMessage('Could not read file inside ZIP: ' + e.message, 'error');
    }
  }

  function displayBlob(blob, name, typeHint){
    viewer.innerHTML = '';
    const url = URL.createObjectURL(blob);
    const mt = typeHint || blob.type || '';

    if (mt.includes('pdf')){
      const obj = document.createElement('object');
      obj.type = 'application/pdf';
      obj.data = url;
      viewer.appendChild(obj);
    } else if (mt.startsWith('image/')){
      const img = document.createElement('img');
      img.src = url;
      img.className = 'viewer-image';
      viewer.appendChild(img);
    } else if (mt.includes('html')) {
      blob.text().then(t => {
        showHtmlString(t, name || 'html', url);
      });
      return;
    } else if (mt.startsWith('text/') || mt.includes('xml')) {
      blob.text().then(t => {
        const pre = document.createElement('pre');
        pre.textContent = t;
        viewer.appendChild(pre);
      });
    } else {
      const pre = document.createElement('pre');
      pre.textContent = 'This file type cannot be displayed directly.\nDownload below.\n\nType: ' + mt;
      viewer.appendChild(pre);
    }

    setCurrentDownload(url, name || 'file.bin');
  }

  async function handleShow(){
    viewer.innerHTML = '';
    fileList.style.display = 'none';
    fileList.innerHTML = '';
    setMessage('', '');

    let raw = (ta.value || '').trim();
    if (!raw){
      setMessage('Please paste Base64 or HTML content first.', 'error');
      return;
    }

    const startTrim = raw.trimStart();
    // raw HTML (not Base64)
    if (!/^data:[^;]+;base64,/i.test(startTrim) && startTrim.startsWith('<')) {
      showHtmlString(startTrim, 'raw HTML');
      setMessage('Raw HTML displayed (not Base64).', 'ok');
      return;
    }

    let { mime, data } = stripDataUrlPrefix(raw);
    let cleaned = cleanBase64(data);

    if (!cleaned){
      setMessage('No Base64 data found.', 'error');
      return;
    }

    // MIME first
    if (mime && mime.includes('zip')){
      await showZipFromBase64(cleaned);
      return;
    }
    if (mime && mime.includes('pdf')){
      showPdfFromBase64(cleaned);
      return;
    }

    // prefix
    if (isLikelyZip(cleaned)){
      await showZipFromBase64(cleaned);
      return;
    }
    if (isLikelyPdf(cleaned)){
      showPdfFromBase64(cleaned);
      return;
    }

    // others
    let bytes;
    try {
      bytes = b64ToUint8Array(cleaned);
    } catch (e){
      setMessage('Base64 decode error: ' + e.message, 'error');
      return;
    }

    const detected = mime || detectMagic(bytes) || 'application/octet-stream';

    if (detected.includes('html')) {
      const html = utf8Decode(bytes);
      const blob = new Blob([html], {type:'text/html'});
      const url = URL.createObjectURL(blob);
      showHtmlString(html, 'Base64 HTML', url);
      setMessage('HTML (Base64) displayed visually.', 'ok');
      return;
    }

    if (detected.startsWith('text/') || detected.includes('xml')) {
      const text = utf8Decode(bytes);
      const pre = document.createElement('pre');
      pre.textContent = text;
      viewer.appendChild(pre);

      const blob = new Blob([text], {type: detected || 'text/plain'});
      const url = URL.createObjectURL(blob);
      setCurrentDownload(url, 'decoded.txt');

      setMessage('Text/XML displayed. Detected type: ' + detected, 'ok');
      return;
    }

    const blob = new Blob([bytes], { type: detected });
    displayBlob(blob, 'decoded.bin', detected);
    setMessage('Detected type: ' + detected, 'ok');
  }
</script>

<footer>
  ¬© 2025 Aylaverse ‚Äî Browser-based developer tools.
</footer>

</body>
</html>
